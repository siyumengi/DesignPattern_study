# DesignPattern_study
java设计模式

## 目的

1. 代码重用性（即：相同功能的代码，不用多次编写）
2. 可读性（编程规范性）
3. 可扩展性（当需要增加新的功能时，非常方便，可维护）
4. 可靠性（增加新的功能后，对原来的功能没有影响）
5. 使程序呈现高内聚，低耦合的特性（）

## 七大原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特法则
7. 合成服用原则

### 单一职责原则

对类来说，即一个类应该只负责一项职责。如果类A负责两个不同职责：职责1，职责2，当职责1需要改变时，可能会造成职责2发生错误，所以要把类A的粒度分解为类A1，A2

#### 注意事项和细节

1. 降低类的复杂度，一个类只负责一项职责
2. 提高类的可读性，可维护性
3. 降低变更引起的风险
4. 通常情况下，应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

### 接口隔离原则

1. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上![image.png](https://cdn.nlark.com/yuque/0/2023/png/32496237/1679224284877-216f21bc-5d1a-4a40-bd17-54dd44f4c76e.png#averageHue=%23f5f8f5&clientId=ubb77da4e-f0ee-4&from=paste&height=411&id=u2f83c25d&name=image.png&originHeight=411&originWidth=451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98255&status=done&style=none&taskId=uba96b37c-d9ce-4207-8f5a-1f1af5ed0d0&title=&width=451)
2. 类 A 通过接口 Interface1 依赖 类 B，类 C 通过接口 Interface 依赖类 D，如果接口 interface 对于类 A 和 类 C 来说不是最小接口，name类 B 和类 D 必须去实现他们不需要的方法
3. 按隔离原则应当这样处理：将接口 interface1 拆分为独立的几个几口，类 A 和 类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则

#### 因传统方法的问题和使用接口隔离原则改进

1. 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法
2. 将接口 interface1 拆分为独立的几个接口，类 A 和 类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则
3. 接口 interface1 中出现的方法，根据实际情况拆分为三个接口
4. ![image.png](https://cdn.nlark.com/yuque/0/2023/png/32496237/1679225116903-d9ee9eca-fff1-4128-9ce6-9352bc449c5c.png#averageHue=%23f5f9f4&clientId=ubb77da4e-f0ee-4&from=paste&height=210&id=ua0d03212&name=image.png&originHeight=210&originWidth=344&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51479&status=done&style=none&taskId=ua0e7e5ba-f6da-437c-be81-00bb0f9f247&title=&width=344)

### 依赖倒转原则

依赖倒转原则(Dependence Inversion Principle)是指:

1. 高模块不应该依赖于低模块，二者都应该依赖抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒转（倒置）的中心思想是面向接口编程
4. 依赖倒转原则是基于这样的设计思想：相对于细节的多变性，抽象的东西要稳定多。以抽象为基础搭建的架构比细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体实现的类
5. 使用接口或抽象类的目的就是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给实现类去完成。

#### 依赖倒转的三种实现方式

1. 接口传递
2. 构造方法传递
3. setter 方法传递

#### 依赖倒转原则的注意事项和细节

1. 底层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
2. 变量的声明类型是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
3. 继承时遵循里氏替换原则
   #### 

### 里氏替换原则

#### OO中的继承性的思考和说明

1. 继承的意思：父类中凡是已经实现好的方法，实际上在设计规范和契约，虽然不强制要求所有的子类必须遵循这样契约，但是如果子类这些已经实现的方法任意修改，就会对整个继承造成破坏
2. 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障

#### 介绍

1. 所有引用基类的地方必须能透明的使用其子类的对象
2. 使用继承时，在子类尽量不要重写父类的方法
3. 继承让两个类耦合性增强，可以通过聚合，组合，依赖解决

### 开闭原则

1. 一个软件实体如类，模块和函数应该**对扩展开放(对提供方)**，**对修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。
2. 当软件需要变化时，尽量**通过扩展软件**实体的行为来实现变化，而不是**通过修改**已有的代码来实现变化。
3. 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

### 迪米特法则

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 迪米特法则(Demeter Principle)又叫**最少知道原则**，即一个类**对自己依赖的类知道的越少越好**。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public方法，不对外泄露任何信息
4. 迪米特法则还有个更简单的定义:只与直接的朋友通信
5. **直接的朋友**:每个对象都会与其他对象有**耦合关系**，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量，方法参数，方法返回值中的类**为直接的朋友，而出现在**局部变量中的类不是直接的朋友**。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

#### 迪米特法则注意事项和细节

1. 迪米特法则的核心是降低类之间的耦合
2. 但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系，并不是要求完全没有依赖关系

### 合成复用的原则

原则是尽量使用 合成/聚合的方式，而不是使用继承

### 设计原则核心思想

1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2. 针对接口编程，而不是针对实现编程。
3. 为了交互对象之间的松耦合设计而努力

## UML 图

1. 用例图（use case）
2. 静态结构图：类图，对象图，包图，组件图，部署图
3. 动态行为图：交互图（时序图与协作图）、状态图、活动图

说明：

1. 类图是描述类与类之间的关系的，是UML图中最核心的

UML类图

1.  用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。
2.  类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合

#### 依赖

1. 类中使用到了对方
2. 如果是类的成员属性
3. 如果是方法的返回类型
4. 是方法接收的参数类型
5. 方法中使用到

#### 泛化

1. 泛化就是继承关系
2. 如果 A 继承了 B 类，A 和 B 存在泛化关系

#### 关系

1. 是依赖的特例
2. 实现

#### 关联

1. 类与类之间的关系，是依赖关系的特例
2. 导航性：双向或单向关系
3. 多重性：1：表示有且仅有一个，0：表示 0个或多个，0,1表示 0个或1个，n...m表示n到m个，m...*表示至少m个

#### 聚合

1. 整体和部分关系，整体与部分可以分开
2. 关联关系的特例，具有导航型和多重性

#### 组合

1. 也是整体与部分的关系，但是整体与部分不可以分开

## 设计模式类型

设计模式分为三种类型，共23种

1. 创建型模式:单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2. 结构型模式:适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3. 行为型模式:模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式(Interpreter模式)、状态模式、策略模式、职责链模式(责任链模式)。

## 单例模式

#### 饿汉式

1. 构造器私有化
2. 类的内部创建一个静态常量
3. 向外暴露一个公共方法获取 getInstance

优点：类装载的时候就完成了实例化，避免了线程同步问题
缺点：在类装载的时候就完成了实例化，没有达到懒加载（laze loading），从头到尾都没使用过，就会造成内存浪费的方法
总结：可用，但是可能会造成内存浪费

#### 饿汉式（静态代码块）

1. 构造器私有化
2. 类的内部定义一个静态常量
3. 在静态代码块执行
4. 向外暴露一个公共方法获取 getInstance

优缺点和上方相同

#### 懒汉式

1. 构造器私有化
2. 类的内部声明一个静态常量
3. 向外暴露一个公共方法获取 getInstance 在里面判断，没创建就 new，创建了就返回

优点：实现了 lazy loading，但是只能在单线程上使用
缺点：多线程下不能保证线程安全
总结：在实际开发中，不要使用这种方式

#### 懒汉式（线程安全，同步方法）

在 getInstance 上加锁
优点：解决了线程不安全问题
缺点：效率太低，每个线程进来时要判断是否上过锁，
结论：在实际开发中，不推荐使用这种方式

#### 懒汉式（线程不安全安全，同步方法）

在new的时候加锁，但是加了个寂寞
没用，看个乐子

#### 懒汉式（线程安全，双重检查）

```java
public static  Singleton5 getInstance() {
    if (instance == null) {
        synchronized (Singleton5.class){
            if (instance == null){
                instance = new Singleton5();
            }

        }
    }
    return instance;
}
```

优点：Double-Check 保证了线程安全，延迟加载，效率高
结论：在实际开发中，推荐

#### 静态内部流

1. 构造方法私有化
2. 定义一个内部静态类
3. 静态公有方法得到实例

优点：

1. 采用了类加载的机制来保证初始化实例时只有一个线程
2. 静态内部类不会类装载时不会立马实例化，而是需要被实例化，调用 getInstance方法时才会加载
3. jvm 保证了线程的安全性
4. 线程安全，利用静态内部类特点实现了延迟加载，效率高
5. 推荐使用

#### 枚举

```java
enum Singleton7{
    INSTANCE;

}
```

1. JDK1.5 避免了线程安全问题，还能防止反序列化问题重新创建新的对象

总结：推荐使用

### 单例模式注意事项和细节说明

1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
2. 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
3. 单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据  源、session工厂等)

## 工厂模式

传统方式的优缺点
优点：好理解，简单易操作
缺点：违反了 ocp 原则，即对扩展开放，对修改关闭。

### 简单工厂

思路：把实例化的操作封装到一个类中，有新的类时，只需要修改该类就可以了。
简单工厂模式就是由一个工厂对象决定创建出哪一种产品类的实例
简单工厂模式：定义一个创建对象的类，由这个类封装实例化对象的行为
在软件开发中，大量的创建某种、某类或者某批对象时，就会使用到工厂模式

### 工厂方法

设计方案：将实例化功能抽象成抽象方法
工厂方法模式：定义一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法将对象的实例化推迟到子类

### 抽象工厂

抽象工厂模式:定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
抽象工厂模式可以将**简单工厂模式**和**工厂方法模式**进行整合。
从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)
将工厂抽象成两层，**AbsFactory**(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了**工厂簇**，更利于代码的维护和扩展。

### 小结

1. 工厂模式的意义
   将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
2. 三种工厂模式(简单工厂模式、工厂方法模式、抽象工厂模式)
3. 设计模式的依赖抽象原则

创建对象实例时，不要直接new类,而是把这个new类的动作放在一个工厂的方法中，并返回。
有的书上说，变量不要直接持有具体类的引用。
不要让类继承具体类，而是继承抽象类或者是实现interface(接口)
不要覆盖基类中已经实现的方法。

## 原型模式

全是new
传统方式的优缺点

1. 优点是比较好理解，操作简单
2. 在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低
3. 总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活

**思路**: Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份,但是需要实现clone的Java类必须要实现一个接口Cloneable,该接口表示该类能够复制且具有复制的能力→>原型模式

### 基本介绍

1. 原型模式(Prototype模式)是指:用**原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的**对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
3. 工作原理是:通过将一个原型对象传给那个要发动创建的对象,这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即**对象.clone()**

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32496237/1679987049693-a7f4d237-de60-4544-9d52-2b05765ece0b.png#averageHue=%23f7f7f6&clientId=uef0e3b55-3561-4&from=paste&height=326&id=u3f5636f9&name=image.png&originHeight=326&originWidth=641&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41394&status=done&style=none&taskId=u87933200-d1f8-473e-aded-bb6ea55c09a&title=&width=641)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/32496237/1679987057564-8147897d-64f9-40ca-bf39-3af53c5e1728.png#averageHue=%23faf8f6&clientId=uef0e3b55-3561-4&from=paste&height=163&id=u14392345&name=image.png&originHeight=163&originWidth=674&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47275&status=done&style=none&taskId=uf4225bec-344c-4337-94e5-9f9ed564e2b&title=&width=674)

### 原型模式在Spring框架中源码分析

![image.png](https://cdn.nlark.com/yuque/0/2023/png/32496237/1679987107321-b6a1dd07-93c1-4c24-82b2-e228d4214452.png#averageHue=%23dbdec9&clientId=uef0e3b55-3561-4&from=paste&height=408&id=u395003d7&name=image.png&originHeight=408&originWidth=958&originalType=binary&ratio=1&rotation=0&showTitle=false&size=420638&status=done&style=none&taskId=ud82d8bb5-b37b-4585-bdcf-ca96abbaad8&title=&width=958)

### 浅拷贝和深拷贝

#### 浅拷贝

1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址〉复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
3. 前面克隆羊就是浅拷贝
4. 浅拷贝是使用默认的clone()方法来实现sheep = (Sheep) super.clone();

#### 深拷贝

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
3. 深拷贝实现方式1:重写clone方法来实现深拷贝
4. 深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)

```java
    //深拷贝方式
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Object deep = null;
        deep = super.clone();
        DeepProtoType deepProtoType = (DeepProtoType) deep;
        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();

        return deepProtoType;
    }

    //    序列化方式
    public Object deepClone() {
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try {
//            序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
//            反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType deepProtoType = (DeepProtoType) ois.readObject();
            return deepProtoType;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
```

### 原型模式的注意事项和细节

1. 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
2. 不用重新初始化对象，而是动态地获得对象运行时的状态
3. 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
4. 在实现深克隆的时候可能需要比较复杂的代码
5. 缺点:需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则

